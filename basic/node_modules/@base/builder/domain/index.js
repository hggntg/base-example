"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const objectPath = __importStar(require("object-path"));
const fs_1 = __importDefault(require("fs"));
const events_1 = require("events");
const path_1 = require("path");
exports.CONFIG = Symbol.for("Config");
exports.APP = Symbol.for("App");
exports.CONFIG_SERVICE = "IBaseConfig";
let AConfig = class AConfig {
    constructor() { }
    static getType() {
        return Type.get("AConfig", "class");
    }
};
AConfig = __decorate([
    Injectable(exports.CONFIG_SERVICE, true),
    __metadata("design:paramtypes", [])
], AConfig);
let DoubleConfig = class DoubleConfig extends AConfig {
    constructor() {
        super();
    }
    setConfig(_configRoot) {
        this.configRoot = _configRoot;
    }
    getSection(ClassImp, sectionName) {
        let dynamicResult = objectPath.get(this.configRoot, sectionName, null);
        let data = mapData(ClassImp, dynamicResult);
        if (data.error)
            handleError(data.error);
        return data.value ? data.value : null;
    }
    static getType() {
        return Type.get("DoubleConfig", "class");
    }
};
DoubleConfig = __decorate([
    Injectable(exports.CONFIG_SERVICE, true, true),
    __metadata("design:paramtypes", [])
], DoubleConfig);
exports.APP_SERVICE = "IApp";
let App = class App {
    constructor() {
        this.logger = getDependency(LOGGER_SERVICE);
        this.event = new events_1.EventEmitter();
        this.preStartAppTasks = new Array();
        this.context = Namespace;
        this.once("preStartApp", () => {
            console.info("Preparing for starting app");
            let promiseList = [];
            this.preStartAppTasks.map(preTask => {
                promiseList.push(preTask);
            });
            Promise.all(promiseList).then((sucess) => {
                this.event.emit("startAppDone", null);
            }).catch(err => {
                throw new Error(err);
            });
        });
        this.once("startAppDone", () => {
            console.info("Application is started");
            this.report({
                description: "Application is started",
                event: "app.ready",
                level: "green",
                meta: {},
                needToRestart: false
            });
        });
    }
    getType() {
        return Type.get("App", "class");
    }
    init(input) {
        this.logger.trace(true);
        this.logger.init({ appName: input.appName });
        if (input.aliases) {
            let aliases = Object.keys(input.aliases);
            Object.values(input.aliases).map((target, index) => {
                addAlias("@" + aliases[index], target);
            });
        }
    }
    loadConfig(path) {
        if (fs_1.default.existsSync(path)) {
            console.info("Reading config from " + path);
            let env = fs_1.default.readFileSync(path, { encoding: "utf8" }).toString();
            let envSegment = env.split("\n");
            envSegment = envSegment.map(envItem => {
                let envItemSegment = envItem.split("=");
                envItemSegment = envItemSegment.map(innerEnvItem => {
                    return innerEnvItem.trim();
                });
                return envItemSegment.join("=");
            });
            envSegment.map(envItem => {
                let envItemSegment = envItem.split("=");
                if (envItemSegment[0] === "NODE_ENV" || !process.env[envItemSegment[0]]) {
                    process.env[envItemSegment[0]] = envItemSegment[1];
                }
            });
        }
        if (!process.env.NODE_ENV) {
            process.env.NODE_ENV = "development";
        }
        if (!process.env.NODE_CONFIG_DIR) {
            throw new Error("Missing config directory");
        }
        let configDir = path_1.join(process.cwd(), process.env.NODE_CONFIG_DIR);
        if (fs_1.default.existsSync(configDir)) {
            let configFileName = process.env.NODE_ENV + ".json";
            if (configFileName === "development.json") {
                if (!fs_1.default.existsSync(path_1.join(configDir, configFileName))) {
                    configFileName = "default.json";
                }
            }
            let configFilePath = path_1.join(configDir, configFileName);
            if (fs_1.default.existsSync(configFilePath)) {
                let configString = fs_1.default.readFileSync(configFilePath, { encoding: "utf8" });
                configString = configString.replace(/\n/g, " ").replace(/\s\s/g, " ");
                try {
                    let config = JSON.parse(configString);
                    this.config = getDependency(exports.CONFIG_SERVICE, true);
                    this.config.setConfig(config);
                }
                catch (e) {
                    throw e;
                }
            }
            else {
                throw new Error("Missing config file for environment " + process.env.NODE_ENV);
            }
        }
        else {
            throw new Error("Missing config dir at path " + process.env.NODE_CONFIG_DIR);
        }
        if (process.env["NODE_ENV"] !== "development") {
            this.logger.setColor(false);
            this.logger.setLevel("warn");
            this.logger.setDisplayAppName(false);
        }
        else {
            this.logger.setColor(true);
            this.logger.setLevel("silly");
            this.logger.setDisplayAppName(true);
        }
    }
    serveAs(_type) {
        this.type = _type;
    }
    use(plugin, preStartApp) {
        try {
            if (preStartApp) {
                this.preStartAppTasks.push(plugin);
            }
        }
        catch (e) {
            throw new Error(e);
        }
        return this;
    }
    report(event) {
        let needToRestart = event.needToRestart;
        delete event.needToRestart;
        if (typeof process.send === "function")
            process.send(event);
        if (needToRestart)
            process.exit(0);
    }
    once(event, cb) {
        return this.event.once(event, cb);
    }
    start() {
        this.event.emit("preStartApp", null);
    }
    static getType() {
        return Type.get("App", "class");
    }
};
App = __decorate([
    Injectable(exports.APP_SERVICE, false, true),
    __metadata("design:paramtypes", [])
], App);
exports.App = App;
