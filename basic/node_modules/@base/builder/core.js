"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const path_1 = require("path");
const module_1 = __importDefault(require("module"));
const inversify_1 = require("inversify");
const asyncHooks = __importStar(require("async_hooks"));
const events_1 = require("events");
if ("undefined" === typeof global["system"]) {
    const system = {
        log: console.log,
        warn: console.warn,
        debug: console.debug,
        error: console.error,
        info: console.info
    };
    global["system"] = system;
}
if ("undefined" === typeof global["getMetadata"]) {
    global["getMetadata"] = function getMetadata(key, target) {
        return Reflect.getMetadata(key, getClass(target));
    };
}
if ("undefined" === typeof global["defineMetadata"]) {
    global["defineMetadata"] = function defineMetadata(key, value, target) {
        return Reflect.defineMetadata(key, value, getClass(target));
    };
}
if ("undefined" === typeof global["generateNewableIdentifier"]) {
    global["generateNewableIdentifier"] = function generateNewableIdentifier(identifier) {
        let newableIdentifier = null;
        if (typeof identifier === "string") {
            newableIdentifier = `Newable<${identifier}>`;
        }
        else {
            let symbolString = identifier.toString().replace("Symbol(", "").replace(")", "");
            newableIdentifier = Symbol.for(`Newable<${symbolString}>`);
        }
        return newableIdentifier;
    };
}
if ("undefined" === typeof global["bindToContainer"]) {
    global["bindToContainer"] = function bindToContainer(container, identifier, service, newable, isDefault) {
        if (typeof newable === "undefined") {
            newable = true;
        }
        if (isDefault) {
            container.bind(identifier).to(service).inSingletonScope().whenTargetIsDefault();
            if (newable) {
                container.bind(generateNewableIdentifier(identifier)).to(service).inTransientScope().whenTargetIsDefault();
            }
        }
        else {
            container.bind(identifier).to(service).inSingletonScope().whenTargetNamed(service.name);
            if (newable) {
                container.bind(generateNewableIdentifier(identifier)).to(service).inTransientScope().whenTargetNamed(service.name);
            }
        }
    };
}
if ("undefined" === typeof global["bindConstantToContainer"]) {
    global["bindConstantToContainer"] = function bindConstantToContainer(container, identifier, constantValue, name) {
        if (!name) {
            container.bind(identifier).toConstantValue(constantValue);
        }
        else {
            container.bind(identifier).toConstantValue(constantValue).whenTargetNamed(name);
        }
    };
}
if ("undefined" === typeof global["rebindToContainer"]) {
    global["rebindToContainer"] = function rebindToContainer(container, identifier, service, newable, isDefault) {
        if (typeof newable === "undefined") {
            newable = true;
        }
        let allBinders = container.getAll(identifier);
        let reBinders = [];
        allBinders.map((binder) => {
            let binderContructor = Object.getPrototypeOf(binder).constructor;
            if (isDefault || (!isDefault && service.name !== binderContructor.name)) {
                reBinders.push(binderContructor);
            }
        });
        if (isDefault) {
            container.rebind(identifier).to(service).inSingletonScope().whenTargetIsDefault();
        }
        else {
            container.rebind(identifier).to(service).inSingletonScope().whenTargetNamed(service.name);
        }
        reBinders.map((binderClass) => {
            container.bind(identifier).to(binderClass).inSingletonScope().whenTargetNamed(binderClass.name);
        });
        if (newable) {
            let allNewableBinders = container.getAll(generateNewableIdentifier(identifier));
            let reNewableBinders = [];
            allNewableBinders.map((newableBinder) => {
                let binderContructor = Object.getPrototypeOf(newableBinder).constructor;
                if (isDefault || (!isDefault && service.name !== binderContructor.name)) {
                    reNewableBinders.push(binderContructor);
                }
            });
            if (isDefault) {
                container.rebind(generateNewableIdentifier(identifier)).to(service).inTransientScope().whenTargetIsDefault();
            }
            else {
                container.rebind(generateNewableIdentifier(identifier)).to(service).inTransientScope().whenTargetNamed(service.name);
            }
            reNewableBinders.map((newBinderClass) => {
                container.bind(generateNewableIdentifier(identifier)).to(newBinderClass).inTransientScope().whenTargetNamed(newBinderClass.name);
            });
        }
    };
}
if ("undefined" === typeof global["registerDependency"]) {
    global["registerDependency"] = function registerDependency(identifier, service, newable, isDefault) {
        if (typeof newable === "undefined") {
            newable = true;
        }
        let container = getMetadata("DI", global);
        if (!container) {
            container = new inversify_1.Container({ skipBaseClassChecks: true });
        }
        if (isDefault) {
            try {
                container.get(identifier);
                rebindToContainer(container, identifier, service, newable, isDefault);
            }
            catch (e) {
                bindToContainer(container, identifier, service, newable, isDefault);
            }
        }
        else {
            bindToContainer(container, identifier, service, newable, isDefault);
        }
        defineMetadata("DI", container, global);
    };
}
if ("undefined" === typeof global["registerDependencyAgain"]) {
    global["registerDependencyAgain"] = function registerDependencyAgain(identifier, service, newable, isDefault) {
        if (typeof newable === "undefined") {
            newable = true;
        }
        let container = getMetadata("DI", global);
        if (!container) {
            container = new inversify_1.Container({ skipBaseClassChecks: true });
        }
        rebindToContainer(container, identifier, service, newable, isDefault);
        defineMetadata("DI", container, global);
    };
}
if ("undefined" === typeof global["registerConstant"]) {
    global["registerConstant"] = function registerConstant(identifier, constantValue, name) {
        let container = getMetadata("DI", global);
        if (!container) {
            container = new inversify_1.Container({ skipBaseClassChecks: true });
        }
        return bindConstantToContainer(container, identifier, constantValue, name);
    };
}
if ("undefined" === typeof global["getDependency"]) {
    global["getDependency"] = function getDependency(identifier, arg0, arg1) {
        let numOfArgs = arguments.length;
        let container = getMetadata("DI", global);
        if (!container) {
            throw new Error("DI Container is not exists");
        }
        else {
            let name = null;
            let newable = false;
            if (numOfArgs === 2) {
                if (typeof arg0 === "string") {
                    name = arg0;
                }
                else {
                    newable = arg0;
                }
            }
            else {
                if (typeof arg0 === "string") {
                    name = arg0;
                }
                else {
                    newable = arg0;
                }
                if (typeof arg1 === "string") {
                    name = arg1;
                }
                else {
                    newable = arg1;
                }
            }
            if (name) {
                if (newable) {
                    return container.getNamed(generateNewableIdentifier(identifier), name);
                }
                else {
                    return container.getNamed(identifier, name);
                }
            }
            else {
                if (newable) {
                    return container.get(generateNewableIdentifier(identifier));
                }
                else {
                    return container.get(identifier);
                }
            }
        }
    };
}
if ("undefined" === typeof global["getConstatnt"]) {
    global["getConstant"] = function getConstant(identifier, name) {
        let container = getMetadata("DI", global);
        if (!container) {
            throw new Error("DI Container is not exists");
        }
        if (name) {
            return container.getNamed(identifier, name);
        }
        else {
            return container.get(identifier);
        }
    };
}
if ("undefined" === typeof global["checkConstant"]) {
    global["checkConstant"] = function checkConstant(identifier, name) {
        let container = getMetadata("DI", global);
        if (container) {
            try {
                let fakeConstant = null;
                if (name) {
                    fakeConstant = container.getNamed(identifier, name);
                }
                else {
                    fakeConstant = container.get(identifier);
                }
                return !!fakeConstant;
            }
            catch (e) {
                return false;
            }
        }
        return false;
    };
}
if ("undefined" === typeof global["checkDependency"]) {
    global["checkDependency"] = function checkDependency(identifier, newable = false, name) {
        let container = getMetadata("DI", global);
        if (container) {
            try {
                let fakeDependency = null;
                if (name) {
                    if (newable) {
                        fakeDependency = container.getNamed(generateNewableIdentifier(identifier), name);
                    }
                    else {
                        fakeDependency = container.getNamed(identifier, name);
                    }
                }
                else {
                    if (newable) {
                        fakeDependency = container.get(generateNewableIdentifier(identifier));
                    }
                    else {
                        fakeDependency = container.get(identifier);
                    }
                }
                return !!fakeDependency;
            }
            catch (e) {
                return false;
            }
        }
        return false;
    };
}
if ("undefined" === typeof global["extendClass"]) {
    global["extendClass"] = function extendClass(derivedCtor, baseCtors, ...moreBaseCtors) {
        moreBaseCtors.unshift(baseCtors);
        moreBaseCtors.forEach(baseCtor => {
            let baseCtorProperties = getProperties(baseCtor);
            baseCtorProperties.map(property => {
                Property(property.type, { required: property.required })(derivedCtor, property.name);
            });
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
                if (name !== 'constructor') {
                    derivedCtor.prototype[name] = baseCtor.prototype[name];
                }
            });
        });
    };
}
if ("undefined" === typeof global["Injectable"]) {
    global["Injectable"] = function Injectable(serviceName, newable, isDefault) {
        return (target) => {
            inversify_1.injectable()(target);
            let targetClass = getClass(target);
            let isExists = checkDependency(serviceName, newable, targetClass.name);
            if (!isExists) {
                registerDependency(serviceName, targetClass, newable, isDefault);
            }
            else {
                registerDependencyAgain(serviceName, targetClass, newable, isDefault);
            }
        };
    };
}
;
if ("undefined" === typeof global["typeKey"]) {
    global["typeKey"] = "Type";
}
if ("undefined" === typeof global["PropertyTypes"]) {
    let PropertyTypes;
    (function (PropertyTypes) {
        PropertyTypes["Any"] = "$_any";
    })(PropertyTypes || (PropertyTypes = {}));
    global["PropertyTypes"] = PropertyTypes;
}
if ("undefined" === typeof global["PROPERTIES_KEY"]) {
    global["PROPERTIES_KEY"] = Symbol.for("property");
}
if ("undefined" === typeof global["CLASS_KEY"]) {
    global["CLASS_KEY"] = Symbol.for("class");
}
if ("undefined" === typeof global["REAL_DATA_TYPE_KEY"]) {
    global["REAL_DATA_TYPE_KEY"] = Symbol.for("real-data-type");
}
if ("undefined" === typeof global["DynamicProperty"]) {
    global["DynamicProperty"] = function DynamicProperty(type, options) {
        return (target) => {
            let columns = getMetadata(PROPERTIES_KEY, target) || [];
            let isPropertyType = type && type.type && type.value;
            let realType;
            if (isPropertyType) {
                realType = type;
            }
            else {
                realType = {
                    type: "single",
                    value: type
                };
            }
            columns.push({ type: realType, name: "$_all", required: (options && options.required) ? true : false });
            defineMetadata(PROPERTIES_KEY, columns, target);
        };
    };
}
if ("undefined" === typeof global["PropertyArray"]) {
    global["PropertyArray"] = function PropertyArray(type) {
        return {
            type: "list",
            value: type
        };
    };
}
if ("undefined" === typeof global["PropertyMap"]) {
    global["PropertyMap"] = function PropertyMap(type) {
        return {
            type: "map",
            value: type
        };
    };
}
if ("undefined" === typeof global["PropertyLiteral"]) {
    global["PropertyLiteral"] = function PropertyLiteral(type, ...moreType) {
        moreType.unshift(type);
        let literalProperty = {
            type: "literal",
            value: []
        };
        moreType.map(type => {
            literalProperty.value.push(type);
        });
        return literalProperty;
    };
}
if ("undefined" === typeof global["Property"]) {
    global["Property"] = function Property(type, options) {
        return (target, propertyKey) => {
            let columns = getMetadata(PROPERTIES_KEY, target) || [];
            let isPropertyType = type && type.type && type.value;
            let realType;
            if (isPropertyType) {
                realType = type;
            }
            else {
                realType = {
                    type: "single",
                    value: type
                };
            }
            columns.push({ type: realType, name: propertyKey, required: (options && options.required) ? true : false });
            defineMetadata(PROPERTIES_KEY, columns, target);
        };
    };
}
if ("undefined" === typeof global["getProperties"]) {
    global["getProperties"] = function getProperties(target) {
        let properties = getMetadata(PROPERTIES_KEY, target);
        return properties || [];
    };
}
if ("undefined" === typeof global["defaultValue"]) {
    global["defaultValue"] = function defaultValue(input, type, truthy = true) {
        if (input === null) {
            if (type === "boolean") {
                return truthy;
            }
            else if (type === "string") {
                return "";
            }
            else if (type === "number") {
                return truthy ? 1 : 0;
            }
            else if (type === "object") {
                return truthy ? {} : null;
            }
        }
        else {
            if (type === "array" && Array.isArray(input)) {
                return input;
            }
            else if (typeof input === type && !Array.isArray(input)) {
                return input;
            }
            else {
                return null;
            }
        }
    };
}
if ("undefined" === typeof global["IsPropertyType"]) {
    global["IsPropertyType"] = function IsPropertyType(propertyType) {
        if (propertyType.type && propertyType.value)
            return true;
        else
            return false;
    };
}
if ("undefined" === typeof global["mapData"]) {
    class MapDataResult {
        static toResult(result, isValid = 1) {
            let data = new MapDataResult();
            data.isValid = isValid;
            data.result = result;
            return data;
        }
    }
    function NullOrUndefined(value) {
        return typeof value === "undefined" || value === null;
    }
    function mapToNumber(input) {
        try {
            let result = Number(input);
            return !isNaN(result);
        }
        catch (e) {
            return false;
        }
    }
    function mapToString(input) {
        try {
            if (input && typeof input !== "object") {
                String(input);
                return true;
            }
            else {
                return false;
            }
        }
        catch (e) {
            return false;
        }
    }
    function mapToBoolean(input) {
        if (input === "true" || input === "false" || input === true || input === false)
            return true;
        return false;
    }
    function mapToObject(input) {
        if (typeof input !== "string" && typeof input === "object")
            return true;
        else {
            try {
                let result = JSON.__base__circularParse(input);
                return true;
            }
            catch (e) {
                return false;
            }
        }
    }
    function checkSourceValue(source, expectType) {
        if (typeof source === expectType)
            return true;
        else {
            if (expectType !== "function") {
                switch (expectType) {
                    case "number": return mapToNumber(source);
                    case "string": return mapToString(source);
                    case "boolean": return mapToBoolean(source);
                }
            }
            return false;
        }
    }
    function mapDataFromPropertyValueObject(dest, propertyTypeValue, name, value, required = false) {
        let isValid = 1;
        let delimiter = typeof name === "string" ? Object.__base__getDelimiter(name) : ".";
        switch (propertyTypeValue.name) {
            case "String":
                if (checkSourceValue(value, "string"))
                    Object.__base__setAt(dest, name, String(value), delimiter);
                else if (required || !NullOrUndefined(value))
                    isValid *= 0;
                break;
            case "Number":
                if (checkSourceValue(value, "number"))
                    Object.__base__setAt(dest, name, Number(value), delimiter);
                else if (required || !NullOrUndefined(value))
                    isValid *= 0;
                break;
            case "Boolean":
                if (checkSourceValue(value, "boolean"))
                    Object.__base__setAt(dest, name, Boolean(value), delimiter);
                else if (required || !NullOrUndefined(value))
                    isValid *= 0;
                break;
            case "Function":
                if (checkSourceValue(value, "function"))
                    Object.__base__setAt(dest, name, value, delimiter);
                else if (required || !NullOrUndefined(value))
                    isValid *= 0;
                break;
            case "Date":
                if (checkSourceValue(value, "string") || checkSourceValue(value, "number") || value instanceof Date) {
                    try {
                        let dataValue = new Date(value);
                        if (dataValue.toString() === "Invalid Date")
                            throw new Error("Invalid Date");
                        else
                            Object.__base__setAt(dest, name, dataValue, delimiter);
                    }
                    catch (e) {
                        if (required || !NullOrUndefined(value))
                            isValid *= 0;
                    }
                }
                else if (required)
                    isValid *= 0;
                break;
            default:
                if (typeof value === "string") {
                    if (mapToObject(value))
                        value = JSON.__base__circularParse(value);
                    else {
                        let fakeType = propertyTypeValue;
                        if (typeof fakeType.__base__fromString === "function")
                            value = fakeType.__base__fromString(value);
                    }
                    let dataResult = mapData(propertyTypeValue, value, name.toString());
                    if (dataResult.error)
                        isValid *= 0;
                    else
                        Object.__base__setAt(dest, name, dataResult.value, delimiter);
                }
                else if (typeof value !== "object") {
                    if (required || !NullOrUndefined(value))
                        isValid *= 0;
                }
                else {
                    let dataResult = mapData(propertyTypeValue, value, name.toString());
                    if (dataResult.error)
                        isValid *= 0;
                    else
                        Object.__base__setAt(dest, name, dataResult.value, delimiter);
                }
        }
        return MapDataResult.toResult(dest, isValid);
    }
    function mapDataFromPropertyValueMap(dest, propertyTypeValue, name, value, required = false) {
        let isValid = 1;
        if (value instanceof Map) {
            let mapDest = new Map();
            value.forEach((v, k) => {
                let innerDest = {};
                if (IsPropertyType(propertyTypeValue)) {
                    if (propertyTypeValue.value === PropertyTypes.Any) {
                        isValid = 1;
                        mapDest.set(k, v);
                    }
                    if (propertyTypeValue.type === "list") {
                        let mapDataResult = mapDataFromPropertyValueList(innerDest, propertyTypeValue.value, k, v, required);
                        isValid *= mapDataResult.isValid;
                        if (isValid && innerDest) {
                            mapDest.set(k, innerDest[k]);
                        }
                    }
                    else if (propertyTypeValue.type === "literal") {
                        let mapDataResult = prepareMapDataForLiteral(innerDest, propertyTypeValue.value, k, v, required);
                        isValid *= mapDataResult.isValid;
                        if (isValid && innerDest) {
                            mapDest.set(k, innerDest[k]);
                        }
                    }
                    else {
                        let mapDataResult = mapDataFromPropertyValueMap(innerDest, propertyTypeValue.value, k, v, required);
                        isValid *= mapDataResult.isValid;
                        if (isValid && innerDest)
                            mapDest.set(k, innerDest[k]);
                    }
                }
                else {
                    let mapDataResult = mapDataFromPropertyValueObject(innerDest, propertyTypeValue, k, v, required);
                    isValid *= mapDataResult.isValid;
                    if (isValid && innerDest)
                        mapDest.set(k, innerDest[k]);
                }
            });
            if (isValid) {
                dest[name] = mapDest;
            }
        }
        else if (!(NullOrUndefined(value)) || (NullOrUndefined(value) && required))
            isValid *= 0;
        return MapDataResult.toResult(dest, isValid);
    }
    function mapDataFromPropertyValueList(dest, propertyTypeValue, name, value, required = false) {
        let isValid = 1;
        if (Array.isArray(value)) {
            let innerDest = [];
            value.map((v, i) => {
                if (IsPropertyType(propertyTypeValue)) {
                    if (propertyTypeValue.value === PropertyTypes.Any) {
                        innerDest.push(v);
                        isValid *= 1;
                    }
                    else if (propertyTypeValue.type === "list") {
                        let mapDataResult = mapDataFromPropertyValueList(innerDest, propertyTypeValue.value, i, v, required);
                        isValid *= mapDataResult.isValid;
                    }
                    else if (propertyTypeValue.type === "literal") {
                        let mapDataResult = prepareMapDataForLiteral(innerDest, propertyTypeValue.value, i, v, required);
                        isValid *= mapDataResult.isValid;
                    }
                    else {
                        let mapDataResult = mapDataFromPropertyValueMap(innerDest, propertyTypeValue.value, i, v, required);
                        isValid *= mapDataResult.isValid;
                    }
                }
                else {
                    let mapDataResult = mapDataFromPropertyValueObject(innerDest, propertyTypeValue, i, v, required);
                    isValid *= mapDataResult.isValid;
                }
            });
            if (isValid && innerDest) {
                dest[name] = innerDest;
            }
        }
        else if (!(NullOrUndefined(value)) || (NullOrUndefined(value) && required))
            isValid *= 0;
        return MapDataResult.toResult(dest, isValid);
    }
    function mapDataFromPropertyValueLiteral(dest, propertyTypeValues, name, value, required = false) {
        let isValid = 1, check = { isSpecific: false, isObject: false, isPropertyType: false };
        if (propertyTypeValues && propertyTypeValues.length > 0) {
            if (typeof propertyTypeValues[0] === "string" || typeof propertyTypeValues[0] === "number" || typeof propertyTypeValues[0] === "boolean")
                check.isSpecific = true;
            else if (typeof propertyTypeValues[0] === "function")
                check.isObject = true;
            else
                check.isPropertyType = true;
        }
        if (check.isSpecific) {
            if (!propertyTypeValues.includes(value))
                isValid *= 0;
            else
                dest[name] = value;
        }
        else if (check.isObject) {
            let length = propertyTypeValues.length, mapDataResult;
            for (let i = 0; i < length; i++) {
                mapDataResult = mapDataFromPropertyValueObject(dest, propertyTypeValues[i], name, value, required);
                if (mapDataResult.isValid)
                    break;
            }
            isValid *= mapDataResult.isValid;
        }
        else if (check.isPropertyType) {
            let length = propertyTypeValues.length, mapDataResult = MapDataResult.toResult(null, 1);
            for (let i = 0; i < length; i++) {
                let propertyType = propertyTypeValues[i];
                if (propertyType.value === PropertyTypes.Any) {
                    dest[name] = value;
                    mapDataResult.isValid = 1;
                    break;
                }
                else if (propertyType.type === "list") {
                    mapDataResult = mapDataFromPropertyValueList(dest, propertyType.value, name, value, required);
                    if (mapDataResult.isValid)
                        break;
                }
                else if (propertyType.type === "literal") {
                    mapDataResult = mapDataFromPropertyValueLiteral(dest, propertyType.value, name, value, required);
                    if (mapDataResult.isValid)
                        break;
                }
                else {
                    mapDataResult = mapDataFromPropertyValueMap(dest, propertyType.value, name, value, required);
                    if (mapDataResult.isValid)
                        break;
                }
            }
            isValid *= mapDataResult.isValid;
        }
        else if (!(NullOrUndefined(value)) || (NullOrUndefined(value) && required))
            isValid *= 0;
        return MapDataResult.toResult(dest, isValid);
    }
    function prepareMapDataForLiteral(dest, propertyTypeValues, name, value, required = false) {
        let isValid = 1, propertyTypeSpecificValues = [], propertyTypeObjectValues = [], propertyTypes = [];
        propertyTypeValues.map(propertyTypeValue => {
            if (typeof propertyTypeValue === "string" || typeof propertyTypeValue === "number" || typeof propertyTypeValue === "boolean")
                propertyTypeSpecificValues.push(propertyTypeValue);
            else if (typeof propertyTypeValue === "function")
                propertyTypeObjectValues.push(propertyTypeValue);
            else
                propertyTypes.push(propertyTypeValue);
        });
        let mapDataResult = mapDataFromPropertyValueLiteral(dest, propertyTypeSpecificValues, name, value, required);
        if (!mapDataResult.isValid)
            mapDataResult = mapDataFromPropertyValueLiteral(dest, propertyTypeObjectValues, name, value, required);
        if (!mapDataResult.isValid)
            mapDataResult = mapDataFromPropertyValueLiteral(dest, propertyTypes, name, value, required);
        isValid *= mapDataResult.isValid;
        return MapDataResult.toResult(dest, isValid);
    }
    function mapDataForSingle(source, dest, property) {
        let isValid = 1;
        let delimiter = Object.__base__getDelimiter(property.name);
        if (source) {
            let value = Object.__base__valueAt(source, property.name, delimiter);
            if (property.type.value === PropertyTypes.Any) {
                dest[property.name] = value;
            }
            else {
                let propertyTypeValue = property.type.value, mapDataResult = mapDataFromPropertyValueObject(dest, propertyTypeValue, property.name, value, property.required);
                isValid = mapDataResult.isValid;
            }
        }
        else if (!(NullOrUndefined(source)) || (NullOrUndefined(source) && property.required))
            isValid *= 0;
        return MapDataResult.toResult(dest, isValid);
    }
    function mapDataForList(source, dest, property) {
        let isValid = 1;
        let delimiter = Object.__base__getDelimiter(property.name);
        if (source) {
            let value = Object.__base__valueAt(source, property.name, delimiter);
            if (property.type.value === PropertyTypes.Any) {
                dest[property.name] = value;
            }
            else {
                let propertyTypeValue = property.type.value, mapDataResult = mapDataFromPropertyValueList(dest, propertyTypeValue, property.name, value, property.required);
                isValid *= mapDataResult.isValid;
            }
        }
        else if (!(NullOrUndefined(source)) || (NullOrUndefined(source) && property.required))
            isValid *= 0;
        return MapDataResult.toResult(dest, isValid);
    }
    function mapDataForLiteral(source, dest, property) {
        let isValid = 1;
        let delimiter = Object.__base__getDelimiter(property.name);
        if (source) {
            let value = Object.__base__valueAt(source, property.name, delimiter);
            if (property.type.value === PropertyTypes.Any) {
                dest[property.name] = value;
            }
            else {
                let propertyTypeValues = property.type.value, mapDataResult = prepareMapDataForLiteral(dest, propertyTypeValues, property.name, value, property.required);
                isValid *= mapDataResult.isValid;
            }
        }
        else if (!(NullOrUndefined(source)) || (NullOrUndefined(source) && property.required))
            isValid *= 0;
        return MapDataResult.toResult(dest, isValid);
    }
    function mapDataForMap(source, dest, property) {
        let isValid = 1;
        let delimiter = Object.__base__getDelimiter(property.name);
        if (source) {
            let value = Object.__base__valueAt(source, property.name, delimiter);
            if (property.type.value === PropertyTypes.Any) {
                dest[property.name] = value;
            }
            else {
                let propertyTypeValue = property.type.value, mapDataResult = mapDataFromPropertyValueMap(dest, propertyTypeValue, property.name, value, property.required);
                isValid *= mapDataResult.isValid;
            }
        }
        else if (!(NullOrUndefined(source)) || (NullOrUndefined(source) && property.required))
            isValid *= 0;
        return MapDataResult.toResult(dest, isValid);
    }
    global["mapData"] = function mapData(ConcreteClass, inputSource, parentField = null) {
        let properties = getProperties(ConcreteClass), isValid = 1, result = {}, missingFields = [], wrongFields = [], source = Object.__base__clone(inputSource);
        properties.map(property => {
            let checkValidCondition = property.required === false || (property.required && property.name === "$_all" && source && Object.keys(source).length > 0) || (property.required && source && source[property.name]);
            if (checkValidCondition)
                isValid *= 1;
            else {
                if (property.name === "$_all" && parentField)
                    missingFields.push(`${parentField}`);
                else {
                    if (parentField)
                        missingFields.push(`${parentField}.${property.name}`);
                    else
                        missingFields.push(property.name === "$_all" ? "" : property.name);
                }
                isValid *= 0;
            }
        });
        if (isValid) {
            result = new ConcreteClass();
            if (properties.length === 0)
                result = source;
            else {
                properties.map(property => {
                    if (property.name !== "$_all") {
                        if (property.type.type === "single") {
                            let mapDataResult = mapDataForSingle(source, result, property);
                            if (!mapDataResult.isValid) {
                                if (parentField)
                                    wrongFields.push(`${parentField}.${property.name}`);
                                else
                                    wrongFields.push(property.name);
                            }
                            isValid *= mapDataResult.isValid;
                        }
                        else if (property.type.type === "list") {
                            let mapDataResult = mapDataForList(source, result, property);
                            if (!mapDataResult.isValid) {
                                if (parentField)
                                    wrongFields.push(`${parentField}.${property.name}`);
                                else
                                    wrongFields.push(property.name);
                            }
                            isValid *= mapDataResult.isValid;
                        }
                        else if (property.type.type === "literal") {
                            let mapDataResult = mapDataForLiteral(source, result, property);
                            if (!mapDataResult.isValid) {
                                if (parentField)
                                    wrongFields.push(`${parentField}.${property.name}`);
                                else
                                    wrongFields.push(property.name);
                            }
                            isValid *= mapDataResult.isValid;
                        }
                        else {
                            let mapDataResult = mapDataForMap(source, result, property);
                            if (!mapDataResult.isValid) {
                                if (parentField)
                                    wrongFields.push(`${parentField}.${property.name}`);
                                else
                                    wrongFields.push(property.name);
                            }
                            isValid *= mapDataResult.isValid;
                        }
                    }
                    else {
                        let keys = Object.keys(source);
                        if (property.type.type === "single") {
                            keys.map((key) => {
                                let tempProperty = Object.__base__clone(property);
                                tempProperty.name = key;
                                let mapDataResult = mapDataForSingle(source, result, tempProperty);
                                if (!mapDataResult.isValid) {
                                    if (parentField)
                                        wrongFields.push(`${parentField}.${key}`);
                                    else
                                        wrongFields.push(key);
                                }
                                isValid *= mapDataResult.isValid;
                            });
                        }
                        else if (property.type.type === "list") {
                            keys.map((key) => {
                                let tempProperty = Object.__base__clone(property);
                                tempProperty.name = key;
                                let mapDataResult = mapDataForList(source, result, tempProperty);
                                if (!mapDataResult.isValid) {
                                    if (parentField)
                                        wrongFields.push(`${parentField}.${key}`);
                                    else
                                        wrongFields.push(key);
                                }
                                isValid *= mapDataResult.isValid;
                            });
                        }
                        else if (property.type.type === "literal") {
                            keys.map((key) => {
                                let tempProperty = Object.__base__clone(property);
                                tempProperty.name = key;
                                let mapDataResult = mapDataForLiteral(source, result, tempProperty);
                                if (!mapDataResult.isValid) {
                                    if (parentField)
                                        wrongFields.push(`${parentField}.${key}`);
                                    else
                                        wrongFields.push(key);
                                }
                                isValid *= mapDataResult.isValid;
                            });
                        }
                        else {
                            keys.map((key) => {
                                let tempProperty = Object.__base__clone(property);
                                tempProperty.name = key;
                                let mapDataResult = mapDataForMap(source, result, tempProperty);
                                if (!mapDataResult.isValid) {
                                    if (parentField)
                                        wrongFields.push(`${parentField}.${key}`);
                                    else
                                        wrongFields.push(key);
                                }
                                isValid *= mapDataResult.isValid;
                            });
                        }
                    }
                });
            }
        }
        if (isValid) {
            return ResultTypeWrapper.wrap(result);
        }
        else {
            let errorString = "";
            if (missingFields.length > 0)
                errorString += `Missing field${missingFields.length > 1 ? "s" : ""} ${missingFields.join(", ")}`;
            if (wrongFields.length > 0)
                errorString += errorString ? `. Invalid field${wrongFields.length > 1 ? "s" : ""} ${wrongFields.join(", ")}` : `Invalid field${wrongFields.length > 1 ? "s" : ""} ${wrongFields.join(", ")}`;
            return ResultTypeWrapper.wrap(new Error(errorString));
        }
    };
}
;
if ("undefined" === typeof global["getClass"]) {
    global["getClass"] = function getClass(target) {
        if (target) {
            if (typeof target === "object" && typeof target.constructor === "function") {
                return target.constructor;
            }
            else {
                return target;
            }
        }
        else {
            throw new Error("Error target is undefined cannot identify a class");
        }
    };
}
if ("undefined" === typeof global["Type"]) {
    global["Type"] = {
        compare(input, name, kind) {
            if (kind) {
                let type = types[kind][name];
                let checked = false;
                switch (kind) {
                    case "class":
                        break;
                    case "construct":
                        break;
                    case "interface":
                        break;
                    case "property":
                        break;
                    case "method":
                        break;
                    default:
                        break;
                }
                return checked;
            }
            else {
                if (name === "array") {
                    return Array.isArray(input);
                }
                return typeof input === name;
            }
        },
        has(name, kind) {
            if (types[kind][name]) {
                return true;
            }
            return false;
        },
        declare(type) {
            let checked = Type.has(type.name, type.kind);
            if (!checked) {
                types[type.kind][type.name] = type;
                defineMetadata(typeKey, types, Type);
            }
        },
        get(name, kind) {
            if (kind) {
                return types[kind][name];
            }
            else {
                return types.intrinsic[name];
            }
        }
    };
    let types = getMetadata("Type", Type);
    if (!types) {
        types = {
            class: {},
            interface: {},
            construct: {},
            method: {},
            property: {},
            intrinsic: {
                Any: { kind: "intrinsic", name: "any" },
                Void: { kind: "intrinsic", name: "void" },
                Number: { kind: "intrinsic", name: "number" },
                String: { kind: "intrinsic", name: "string" },
                Object: { kind: "intrinsic", name: "object" },
                Boolean: { kind: "intrinsic", name: "boolean" },
                Array: { kind: "intrinsic", name: "array" }
            }
        };
        defineMetadata(typeKey, types, Type);
    }
}
;
const AsyncFunction = Object.getPrototypeOf(async function () { }).constructor;
if ("undefined" === typeof global["Context"]) {
    class Context {
        constructor(input) {
            if (input) {
                this._type = input.type;
                this._resource = input.resource;
                this.value = input.value;
                this.children = input.children;
                this.manual = input.manual;
                this.prev = input.prev;
            }
        }
        clone() {
            throw new Error("Method not implemented.");
        }
        toJSON() {
            throw new Error("Method not implemented.");
        }
        fromJSON(input) {
            throw new Error("Method not implemented.");
        }
        init(input) {
            throw new Error("Method not implemented.");
        }
        getType() {
            throw new Error("Method not implemented.");
        }
        set type(value) {
            this._type = value;
        }
        set resource(value) {
            this._resource = value;
        }
        originValue() {
            return {
                value: this.value,
                prev: this.prev,
                manual: this.manual,
                children: this.children
            };
        }
        rawValue() {
            return {
                resource: this._resource,
                type: this._type,
                value: this.value,
                prev: this.prev,
                manual: this.manual,
                children: this.children
            };
        }
    }
    global["Context"] = Context;
}
if ("undefined" === typeof global["createHooks"]) {
    global["createHooks"] = function createHooks(namespace) {
        function init(asyncId, type, triggerId, resource) {
            let parent = namespace.getById(triggerId);
            if (parent) {
                let current = namespace.getById(asyncId);
                if (!current) {
                    current = new Context({
                        value: {},
                        type: type,
                        resource: resource,
                        manual: false,
                        prev: null
                    });
                }
                current.value = parent.value || {};
                current.manual = false;
                current.prev = triggerId;
                current.held = parent.held || false;
                current.resourceId = parent.resourceId || undefined;
                let hasParentResource = true;
                if (!current.resourceId && current.resourceId !== 0) {
                    current.resourceId = namespace.currentValueIndex++;
                    parent.resourceId = current.resourceId;
                    hasParentResource = false;
                }
                if (!namespace.valueContexts[current.resourceId]) {
                    namespace.valueContexts[current.resourceId] = {
                        sharedHolders: [asyncId],
                        value: {}
                    };
                }
                else {
                    namespace.valueContexts[current.resourceId].sharedHolders.push(asyncId);
                }
                if (!hasParentResource && parent) {
                    namespace.valueContexts[current.resourceId].sharedHolders.push(triggerId);
                }
                namespace.setById(asyncId, current);
                if (!parent.children) {
                    parent.children = [];
                }
                parent.children.push(asyncId);
                namespace.setById(triggerId, parent);
            }
        }
        function destroy(asyncId) {
            namespace.flush(asyncId, true);
        }
        function after(asyncId) {
            namespace.flush(asyncId);
        }
        function promiseResolve(asyncId) {
            namespace.flush(asyncId);
        }
        const asyncHook = asyncHooks.createHook({ init, destroy, after, promiseResolve });
        asyncHook.enable();
    };
}
if ("undefined" === typeof global["Namespace"]) {
    class Namespace {
        constructor() {
            this.currentValueIndex = 0;
            this.valueContexts = {};
            this.context = {};
            setInterval(() => {
                this.clearValueContext();
            }, 5000);
        }
        static create(name) {
            if (Namespace.namespaces[name]) {
                throw new Error(`A namespace for \${name} is already exists`);
            }
            let namespace = new Namespace();
            Namespace.namespaces[name] = namespace;
            createHooks(namespace);
            return namespace;
        }
        static get(name) {
            return Namespace.namespaces[name];
        }
        static destroy(name) {
            delete Namespace.namespaces[name];
        }
        clearValueContext() {
            let keys = Object.keys(this.valueContexts);
            let start = Number(keys[0]);
            for (let i = start; i <= this.currentValueIndex; i++) {
                let valueContext = this.valueContexts[i.toString()];
                if (valueContext) {
                    let valueKeys = Object.keys(valueContext.value || {});
                    if (valueKeys.length === 0) {
                        valueContext.sharedHolders.map(sharedHolder => {
                            this.flush(sharedHolder, true);
                        });
                    }
                }
            }
        }
        cloneById(sourceId) {
            let source = this.getById(sourceId);
            let destValue = Object.__base__clone(source.value);
            let dest = new Context({
                children: [],
                flushed: false,
                held: false,
                manual: true,
                prev: null,
                value: destValue,
                type: source.type,
                resource: source.resource ? Object.__base__clone(source.resource) : undefined,
                resourceId: source.resourceId
            });
            this.setById(asyncHooks.triggerAsyncId(), dest);
        }
        holdById(id) {
            let current = this.getById(id);
            if (current) {
                current.held = true;
                this.setById(id, current);
            }
        }
        getCurrentId() {
            return asyncHooks.executionAsyncId();
        }
        getParentId() {
            return asyncHooks.triggerAsyncId();
        }
        originValue() {
            let origins = {};
            let valueKeys = Object.keys(this.context);
            Object.values(this.context).map((value, index) => {
                if (typeof value.originValue === "function") {
                    origins[valueKeys[index]] = value.originValue();
                }
                else {
                    origins[valueKeys[index]] = value;
                }
            });
            return origins;
        }
        rawValue() {
            let raws = {};
            let valueKeys = Object.keys(this.context);
            Object.values(this.context).map((value, index) => {
                if (typeof value.rawValue === "function") {
                    raws[valueKeys[index]] = value.rawValue();
                }
                else {
                    raws[valueKeys[index]] = value;
                }
            });
            return raws;
        }
        run(func) {
            let asyncId = asyncHooks.executionAsyncId();
            let triggerId = asyncHooks.triggerAsyncId();
            let parent = this.getById(triggerId);
            while (!parent && triggerId > 0) {
                triggerId--;
                parent = this.getById(triggerId);
            }
            if (parent) {
                let current = this.getById(asyncId);
                if (!current) {
                    current = new Context({
                        value: {},
                        manual: false,
                        prev: null
                    });
                }
                current.value = parent.value || {};
                current.manual = true;
                current.prev = triggerId;
                current.held = parent.held || false;
                current.resourceId = parent.resourceId;
                if (current.resourceId || current.resourceId === 0)
                    this.valueContexts[current.resourceId].sharedHolders.push(asyncId);
                else {
                    current.resourceId = this.currentValueIndex++;
                    parent.resourceId = current.resourceId;
                    this.valueContexts[current.resourceId] = {
                        sharedHolders: [triggerId, asyncId],
                        value: {}
                    };
                }
                this.setById(asyncId, current);
                if (!parent.children) {
                    parent.children = [];
                }
                parent.children.push(asyncId);
                this.setById(triggerId, parent);
            }
            else {
                let current = this.getById(asyncId);
                if (!current) {
                    current = new Context({
                        value: {},
                        manual: false,
                        prev: null
                    });
                }
                current.value = {};
                current.manual = true;
                if (!current.resourceId && current.resourceId !== 0) {
                    current.resourceId = this.currentValueIndex;
                    this.valueContexts[this.currentValueIndex++] = {
                        value: {},
                        sharedHolders: [asyncId]
                    };
                }
                this.setById(asyncId, current);
            }
            if (func instanceof AsyncFunction) {
                return func();
            }
            else {
                return new Promise((resolve, reject) => {
                    try {
                        func();
                        resolve();
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }
        }
        getById(id) {
            return this.context[id];
        }
        setById(id, value) {
            if (!value.resourceId && value.resourceId !== 0) {
                value.resourceId = this.currentValueIndex++;
            }
            if (this.valueContexts[value.resourceId]) {
                this.valueContexts[value.resourceId].value = value.value;
            }
            else {
                this.valueContexts[value.resourceId] = {
                    sharedHolders: [id],
                    value: value.value
                };
            }
            this.context[id] = value;
        }
        removeById(id, key = undefined) {
            let current = this.context[id];
            if (current) {
                if (current.value) {
                    delete current.value[key];
                }
                if (current.resourceId || current.resourceId === 0) {
                    if (this.valueContexts[current.resourceId]) {
                        delete this.valueContexts[current.resourceId].value[key];
                    }
                }
            }
        }
        set(key, value) {
            const eid = asyncHooks.executionAsyncId();
            if (!this.context[eid]) {
                this.context[eid] = new Context({
                    value: {},
                    manual: true,
                    prev: asyncHooks.triggerAsyncId()
                });
            }
            let current = this.context[eid];
            current.manual = true;
            if (!current.resourceId && current.resourceId !== 0) {
                let parent = this.context[current.prev];
                current.resourceId = parent ? parent.resourceId : undefined;
                if (!current.resourceId && current.resourceId !== 0) {
                    current.resourceId = this.currentValueIndex++;
                }
            }
            if (this.valueContexts[current.resourceId]) {
                if (!this.valueContexts[current.resourceId].sharedHolders.includes(eid))
                    this.valueContexts[current.resourceId].sharedHolders.push(eid);
                this.valueContexts[current.resourceId].value[key] = value;
            }
            else {
                this.valueContexts[current.resourceId] = {
                    sharedHolders: [eid],
                    value: {}
                };
                this.valueContexts[current.resourceId].value[key] = value;
            }
            this.context[eid]["value"] = this.valueContexts[current.resourceId].value;
        }
        setValueById(id, key, value) {
            let current = this.getById(id);
            if (!current.resourceId && current.resourceId !== 0) {
                current.resourceId = this.currentValueIndex++;
            }
            if (!this.valueContexts[current.resourceId]) {
                this.valueContexts[current.resourceId] = {
                    sharedHolders: [id],
                    value: {}
                };
            }
            this.valueContexts[current.resourceId].value[key] = value;
            current.value[key] = value;
            this.context[id] = current;
        }
        get(key) {
            const eid = asyncHooks.executionAsyncId();
            let current = this.getById(eid);
            if (current) {
                if (current.value) {
                    return current.value[key];
                }
            }
            return null;
        }
        getValueById(id, key) {
            const current = this.getById(id);
            if (current) {
                if (current.value) {
                    return current.value[key];
                }
            }
            return null;
        }
        remove(key) {
            const eid = asyncHooks.executionAsyncId();
            let current = this.getById(eid);
            if (current) {
                if (current.value) {
                    delete current.value[key];
                }
                if (current.resourceId || current.resourceId === 0) {
                    if (this.valueContexts[current.resourceId]) {
                        delete this.valueContexts[current.resourceId].value[key];
                    }
                }
            }
            this.setById(eid, current);
        }
        flush(id, force = false) {
            let current = this.getById(id);
            if (current && force) {
                if (current.resourceId || current.resourceId === 0) {
                    if (this.valueContexts[current.resourceId]) {
                        this.valueContexts[current.resourceId].sharedHolders.map((sharedHolder, i, arr) => {
                            if (sharedHolder === id) {
                                arr.splice(i, 1);
                            }
                        });
                        if (this.valueContexts[current.resourceId].sharedHolders.length === 0) {
                            delete this.valueContexts[current.resourceId];
                        }
                    }
                }
                (current.children || []).map(childId => {
                    this.flush(childId, force);
                });
                delete this.context[id];
            }
        }
        dispose() {
            this.context = {};
        }
    }
    Namespace.namespaces = {};
    global["Namespace"] = Namespace;
}
;
if ("undefined" === typeof global["LOGGER_SERVICE"]) {
    global["LOGGER_SERVICE"] = "ILogger";
}
if ("undefined" === typeof global["LOGGER_UTILS"]) {
    global["LOGGER_UTILS"] = {
        reset: "\x1b[0m",
        bright: "x1b[1m",
        dim: "\x1b[2m",
        bold: "\u001b[1m",
        underline: "\x1b[4m",
        blink: "\x1b[5m",
        reverse: "\x1b[7m",
        hidden: "\x1b[8m",
        fgblack: "\x1b[30m",
        fgred: "\x1b[31m",
        fggreen: "\x1b[32m",
        fgyellow: "\x1b[33m",
        fgblue: "\x1b[34m",
        fgmagenta: "\x1b[35m",
        fgcyan: "\x1b[36m",
        fgwhite: "\x1b[37m",
        bgblack: "\x1b[40m",
        bgred: "\x1b[41m",
        bggreen: "\x1b[42m",
        bgyellow: "\x1b[43m",
        bgblue: "\x1b[44m",
        bgmagenta: "\x1b[45m",
        bgcyan: "\x1b[46m",
        bgwhite: "\x1b[47m"
    };
}
if ("undefined" === typeof global["FONT_COLOR_DEFAULT"]) {
    global["FONT_COLOR_DEFAULT"] = ["red", "green", "yellow", "blue", "magenta", "cyan", "white"];
}
if ("undefined" === typeof global["FONT_COLOR_DEFAULT_LENGTH"]) {
    global["FONT_COLOR_DEFAULT_LENGTH"] = FONT_COLOR_DEFAULT.length;
}
if ("undefined" === typeof global["logger"]) {
    class Logger {
        constructor() {
            this.logLevels = {
                silly: ["silly", "info", "debug", "warn", "error"],
                info: ["info", "debug", "warn", "error"],
                debug: ["info", "debug", "warn", "error"],
                warn: ["info", "warn", "error"],
                error: ["info", "error"]
            };
            this.eventInstance = new events_1.EventEmitter();
            this.on("data", (data) => {
                let message = "";
                if (typeof data !== "string") {
                    message = JSON.stringify(data);
                }
                else {
                    message = data;
                }
                if (message !== "\n") {
                    message = message.replace(/[\n\n]/g, "\n");
                    if (message.lastIndexOf("\n") !== message.length - 1) {
                        message += "\n";
                    }
                }
                process.stdout.write(message);
            });
            this.showAppName = true;
            this.logColor = true;
            this.currentLogLevel = "silly";
        }
        on(event, listener) {
            this.eventInstance.on(event, listener);
            return this;
        }
        loggable(level) {
            return this.tracing && this.logLevels[this.currentLogLevel].includes(level);
        }
        styleMessage(style) {
            let outputString = "";
            if (this.logColor) {
                if (style.bold) {
                    outputString += `${LOGGER_UTILS.bold}`;
                }
                if (style.underline) {
                    outputString += `${LOGGER_UTILS.underline}`;
                }
                if (style.fontColor) {
                    outputString += `${LOGGER_UTILS["fg" + style.fontColor]}`;
                }
                if (style.backgroundColor) {
                    outputString += `${LOGGER_UTILS["bg" + style.backgroundColor]}`;
                }
            }
            return outputString;
        }
        expand() {
            let newLogInstance = getDependency(LOGGER_SERVICE, true);
            newLogInstance.init({ appName: this.appName, logColor: this.logColor });
            newLogInstance.trace(this.tracing);
            newLogInstance.setLevel(this.currentLogLevel);
            newLogInstance.setColor(this.logColor);
            newLogInstance.setDisplayAppName(this.showAppName);
            return newLogInstance;
        }
        setColor(logColor) {
            this.logColor = logColor;
        }
        setDisplayAppName(showAppName) {
            this.showAppName = showAppName;
        }
        setLevel(level) {
            this.currentLogLevel = level;
        }
        pushLog(arg0, arg1, arg2, arg3) {
            if (typeof arg0 === "string" && this.loggable(arg1)) {
                let outputString = "";
                let message = arg0;
                let level = arg1;
                let tag = arg2;
                let style = arg3;
                if (style) {
                    outputString += this.styleMessage(style);
                }
                let date = new Date();
                let dateString = `${this.styleMessage({ fontColor: "cyan" }) + date.toISOString()}(${date.toLocaleString()})${this.logColor ? LOGGER_UTILS.reset : ""}`;
                let prefix = `${this.styleMessage({ fontColor: "white" })}SILLY`;
                if (level === "debug") {
                    prefix = `${this.styleMessage({ fontColor: "blue" })}DEBUG`;
                }
                else if (level === "info") {
                    prefix = `${this.styleMessage({ fontColor: "green" })} INFO`;
                }
                else if (level === "error") {
                    prefix = `${this.styleMessage({ fontColor: "red" })}ERROR`;
                }
                else if (level === "warn") {
                    prefix = `${this.styleMessage({ fontColor: "yellow" })} WARN`;
                }
                prefix += `${this.logColor ? LOGGER_UTILS.reset : ""}`;
                message = `${outputString}${message}${this.logColor ? LOGGER_UTILS.reset : ""}`;
                let resultString = (this.showAppName ? `${this.displayAppName} - ` : "") + `${dateString} - ${prefix}${tag ? " - [" + tag + "]" : ""} - ${message}`;
                this.eventInstance.emit("data", resultString);
            }
            else if (arg0 && this.loggable(arg0.level)) {
                let log = arg0;
                let messageText = [];
                let tag = log.message.tag;
                log.message.messages.map(message => {
                    let outputString = "";
                    if (message.style) {
                        outputString += this.styleMessage(message.style);
                    }
                    outputString += message.text + `${this.logColor ? LOGGER_UTILS.reset : ""}`;
                    messageText.push(outputString);
                });
                let date = new Date();
                let dateString = `${this.styleMessage({ fontColor: "cyan" })}${date.toISOString()}(${date.toLocaleString()})${this.logColor ? LOGGER_UTILS.reset : ""}`;
                let prefix = `${this.styleMessage({ fontColor: "white" })}SILLY`;
                if (log.level === "debug") {
                    prefix = `${this.styleMessage({ fontColor: "blue" })}DEBUG`;
                }
                else if (log.level === "info") {
                    prefix = `${this.styleMessage({ fontColor: "green" })} INFO`;
                }
                else if (log.level === "error") {
                    prefix = `${this.styleMessage({ fontColor: "red" })}ERROR`;
                }
                else if (log.level === "warn") {
                    prefix = `${this.styleMessage({ fontColor: "yellow" })} WARN`;
                }
                prefix += `${this.logColor ? LOGGER_UTILS.reset : ""}`;
                let resultString = (this.showAppName ? `${this.displayAppName} - ` : "") + `${dateString} - ${prefix}${tag ? " - [" + tag + "]" : ""} - ${messageText.join(log.message.delimiter)}`;
                this.eventInstance.emit("data", resultString);
            }
        }
        pushWarn(message, tag) {
            this.pushLog(message, "warn", tag, { fontColor: "yellow" });
        }
        pushError(message, tag) {
            this.pushLog(message, "error", tag, { fontColor: "red" });
        }
        pushSilly(message, tag) {
            this.pushLog(message, "silly", tag, { fontColor: "white" });
        }
        pushDebug(message, tag) {
            this.pushLog(message, "debug", tag, { fontColor: "blue" });
        }
        pushInfo(message, tag) {
            this.pushLog(message, "info", tag, { fontColor: "green" });
        }
        trace(tracing) {
            this.tracing = tracing;
        }
        init(input) {
            let fontColorIndex = Math.floor(Math.random() * FONT_COLOR_DEFAULT_LENGTH);
            let fontColor = FONT_COLOR_DEFAULT[fontColorIndex];
            if (input.appName) {
                if (Logger.maxLength <= input.appName.length) {
                    Logger.maxLength = input.appName.length;
                }
                else {
                    let missingLength = Logger.maxLength - input.appName.length;
                    for (let i = 0; i < missingLength; i++) {
                        input.appName = " " + input.appName;
                    }
                }
                this.appName = input.appName;
                this.displayAppName = `${this.styleMessage({ fontColor: fontColor })}${input.appName}${this.logColor ? LOGGER_UTILS.reset : ""}`;
            }
        }
    }
    Logger.maxLength = 0;
    Injectable(LOGGER_SERVICE, true, true)(Logger);
    global["logger"] = getDependency(LOGGER_SERVICE);
    logger.trace(true);
    logger.setColor(true);
    logger.setDisplayAppName(true);
    console.log = function () {
        try {
            let outputString = generateLog.apply(null, arguments);
            if (outputString)
                logger.pushSilly(outputString, "system");
        }
        catch (e) {
            system.error(e);
            system.log.apply(console, arguments);
        }
    };
    console.warn = function () {
        try {
            let outputString = generateLog.apply(null, arguments);
            if (outputString)
                logger.pushWarn(outputString, "system");
        }
        catch (e) {
            system.warn.apply(console, arguments);
        }
    };
    console.error = function () {
        try {
            let outputString = generateLog.apply(null, arguments);
            if (outputString)
                logger.pushError(outputString, "system");
        }
        catch (e) {
            system.error.apply(console, arguments);
        }
    };
    console.debug = function () {
        try {
            let outputString = generateLog.apply(null, arguments);
            if (outputString)
                logger.pushDebug(outputString, "system");
        }
        catch (e) {
            system.debug.apply(console, arguments);
        }
    };
    console.info = function () {
        try {
            let outputString = generateLog.apply(null, arguments);
            if (outputString)
                logger.pushInfo(outputString, "system");
        }
        catch (e) {
            system.info.apply(console, arguments);
        }
    };
}
if ("undefined" === typeof global["generateLog"]) {
    global["generateLog"] = function () {
        let length = arguments.length;
        let outputMessage = [];
        for (let i = 0; i < length; i++) {
            let key = i.toString();
            if ("undefined" === typeof arguments[key]) {
                outputMessage.push("undefined");
            }
            else if (arguments[key] === null) {
                outputMessage.push("null");
            }
            else if (typeof arguments[key] === "number" || typeof arguments[key] === "boolean") {
                outputMessage.push(arguments[key].toString());
            }
            else if (BaseError.isInstance(arguments[key])) {
                let error = arguments[key];
                if (!error.logged) {
                    outputMessage.push(error.stack);
                    error.logged = true;
                }
            }
            else if (arguments[key] instanceof Error) {
                outputMessage.push(arguments[key].stack);
            }
            else if (typeof arguments[key] === "object") {
                if (typeof arguments[key].toString === "function" && !Array.isArray(arguments[key]) && arguments[key].toString() !== "[object Object]")
                    outputMessage.push(arguments[key].toString());
                else
                    outputMessage.push(JSON.__base__circularStringify(arguments[key]));
            }
            else {
                outputMessage.push(arguments[key]);
            }
        }
        let outputString = outputMessage.join(" ").trim();
        return outputString;
    };
}
;
if ("undefined" === typeof global["ErrorLevel"]) {
    class ErrorLevel {
        static isInstance(input) {
            if (input && input.level === "red" || input.level === "green") {
                return true;
            }
            return false;
        }
        static asInstance(input) {
            return input;
        }
        static has(input, key) {
            if (input && input[key]) {
                return true;
            }
            return false;
        }
    }
    const redLevel = new ErrorLevel();
    redLevel.level = "red";
    const greenLevel = new ErrorLevel();
    greenLevel.level = "green";
    global["ErrorLevel"] = ErrorLevel;
    global["ErrorLevel"].RED = redLevel;
    global["ErrorLevel"].GREEN = greenLevel;
}
if ("undefined" === typeof global["BaseError"]) {
    class BaseError extends Error {
        constructor(arg0, arg1, arg2, arg3) {
            if (arguments.length === 4) {
                super(arg2);
                this.code = arg0;
                this.specificCode = arg1;
                this.level = ErrorLevel.asInstance(arg3).level;
            }
            else if (arguments.length === 3) {
                if (ErrorLevel.isInstance(arg2)) {
                    super(arg1);
                    this.code = arg0;
                    this.specificCode = arg1;
                    this.level = ErrorLevel.asInstance(arg2).level;
                }
                else {
                    super(arg2);
                    this.code = arg0;
                    this.specificCode = arg1;
                    this.level = "green";
                }
            }
            else if (arguments.length === 2) {
                if (ErrorLevel.isInstance(arg1)) {
                    super(arg1);
                    this.code = 0;
                    this.specificCode = 0;
                    this.level = ErrorLevel.asInstance(arg1).level;
                }
                else {
                    super(arg1);
                    this.code = arg0;
                    this.specificCode = arg0;
                    this.level = "green";
                }
            }
            else {
                super(arg0);
                this.code = 500;
                this.specificCode = 500;
                this.level = "green";
            }
            this.logged = false;
        }
        static isInstance(input) {
            let isValid = 1;
            if (input && input instanceof Error) {
                let keys = ["code", "specificCode", "name", "message", "level", "stack", "logged"];
                keys.map(key => {
                    isValid *= this.has(input, key) ? 1 : 0;
                });
                if (isValid)
                    return true;
            }
            return false;
        }
        static has(input, key) {
            if (input && typeof input[key] !== "undefined" && input[key] !== null) {
                return true;
            }
            return false;
        }
        static asInstance(input) {
            return input;
        }
    }
    global["BaseError"] = BaseError;
}
if ("undefined" === typeof global["handleError"]) {
    global["handleError"] = function handleError(e, messageOrErrorLevel) {
        let baseError;
        if (e instanceof Error && !BaseError.isInstance(e)) {
            if (messageOrErrorLevel) {
                if (ErrorLevel.isInstance(messageOrErrorLevel)) {
                    baseError = new BaseError(e.message, ErrorLevel.asInstance(messageOrErrorLevel));
                    baseError.stack = e.stack;
                }
                else {
                    baseError = new BaseError(e.message);
                    baseError.stack = e.stack;
                    let message = baseError.message + " --> " + messageOrErrorLevel;
                    baseError.stack = baseError.stack.replace(baseError.message, message);
                    baseError.message = message;
                }
            }
            else {
                baseError = new BaseError(e.message);
                baseError.stack = e.stack;
            }
        }
        else {
            baseError = e;
            if (messageOrErrorLevel) {
                if (ErrorLevel.isInstance(messageOrErrorLevel)) {
                    if (baseError.level === "green")
                        baseError.level = ErrorLevel.asInstance(messageOrErrorLevel).level;
                }
                else {
                    let message = baseError.message + " --> " + messageOrErrorLevel;
                    baseError.stack = baseError.stack.replace(baseError.message, message);
                    baseError.message = message;
                }
            }
        }
        process.emit("app-error", baseError);
        return baseError;
    };
}
if ("undefined" === typeof global["ResultTypeWrapper"]) {
    class ResultTypeWrapper {
        static wrap(input) {
            let result = new ResultTypeWrapper();
            if (input instanceof Error || BaseError.isInstance(input)) {
                result.error = handleError(input);
            }
            else {
                result.value = input;
            }
            return result;
        }
    }
    global["ResultTypeWrapper"] = ResultTypeWrapper;
}
;
if (!process.watcher) {
    process.watcher = {
        emit: function (events, id) {
            this.event.emit("STOP", id);
        },
        init() {
            if (!this.isInit) {
                this.isInit = true;
                this.event.on("STOP", (id) => {
                    this.memberIds[id] = "stopped";
                    let stopped = true;
                    Object.values(this.memberIds).map(status => {
                        if (status === "active") {
                            stopped = false;
                        }
                    });
                    if (stopped) {
                        console.log("Kill this process.........");
                        process.exit(0);
                    }
                });
            }
        },
        joinFrom(id) {
            let keys = Object.keys(this.memberIds);
            if (!keys.includes(id)) {
                this.memberIds[id] = "active";
            }
        }
    };
    Object.defineProperty(process.watcher, "memberIds", {
        configurable: false,
        writable: true,
        value: {}
    });
    Object.defineProperty(process.watcher, "isInit", {
        configurable: false,
        writable: true,
        value: false
    });
    Object.defineProperty(process.watcher, "event", {
        configurable: false,
        writable: false,
        value: new events_1.EventEmitter()
    });
    process.watcher.init();
}
;
if ("undefined" === typeof JSON.__base__circularToken)
    JSON.__base__circularToken = Symbol.for("Circular");
if ("undefined" === typeof JSON.__base__circularStringify) {
    Object.defineProperty(JSON, "__base___circularStringify", {
        writable: false,
        configurable: false,
        value: function (value, cache, parentKey) {
            let jsonString = "";
            if (value !== undefined && value !== null) {
                if (typeof value === "object") {
                    if (!cache) {
                        cache = {};
                        cache["root"] = value;
                    }
                    if (parentKey)
                        cache[parentKey] = value;
                    let jsons = [];
                    if (typeof value.__base__toJSON === "function") {
                        let jsonValue = value.__base__toJSON();
                        if (jsonValue)
                            jsons.push(`${jsonValue}`);
                    }
                    else if (Array.isArray(value)) {
                        let jsonValue = Array.__base__toJSON(value);
                        jsons.push(`${jsonValue}`);
                    }
                    else if (typeof value.toJSON === "function") {
                        let jsonValue = value.toJSON();
                        if (jsonValue)
                            jsons.push(`${jsonValue}`);
                    }
                    else if (typeof value.toString === "function" && value.toString().indexOf("[object") !== 0) {
                        let jsonValue = value.toString();
                        if (jsonValue)
                            jsons.push(`${jsonValue}`);
                    }
                    else {
                        let keys = Object.keys(value), cacheKeys = Object.keys(cache), cacheKeyLength = cacheKeys.length;
                        let innerJSONs = [];
                        Object.values(value).map((v, i) => {
                            if (typeof v === "object") {
                                let isCircular = false, root = cache["root"], circularKey = "root";
                                let delimiter = Object.__base__getDelimiter(cacheKeys[i]);
                                for (let i = 0; i < cacheKeyLength - 1; i++) {
                                    if (cacheKeys[i] === "root" && v === root) {
                                        isCircular = true;
                                        break;
                                    }
                                    else if (parentKey && parentKey.toString().indexOf(cacheKeys[i]) === 0 && v === Object.__base__valueAt(root, cacheKeys[i], delimiter)) {
                                        isCircular = true;
                                        circularKey += "." + cacheKeys[i];
                                        break;
                                    }
                                }
                                if (!isCircular) {
                                    let key = parentKey ? `${parentKey}.${keys[i]}` : `${keys[i]}`, jsonValue = JSON["__base___circularStringify"](v, cache, key);
                                    if (Array.isArray(value))
                                        innerJSONs.push(`\"${jsonValue}"`);
                                    else
                                        innerJSONs.push(`\"${keys[i]}\":${jsonValue}`);
                                }
                                else
                                    innerJSONs.push(`\"${keys[i]}\":\"${JSON.__base__circularToken.toString()}[${circularKey}]\"`);
                            }
                            else {
                                let jsonValue = v;
                                if (typeof v === "string")
                                    jsonValue = `\"${jsonValue}\"`;
                                innerJSONs.push(`\"${keys[i]}\":${jsonValue}`);
                            }
                        });
                        jsons.push(`{${innerJSONs.join(",")}}`);
                    }
                    jsonString = `${jsons.join(",")}`;
                }
                else if (typeof value !== "function") {
                    jsonString = value.toString();
                }
            }
            else {
                if (typeof value === "undefined")
                    jsonString = "undefined";
                else
                    jsonString = "null";
            }
            return jsonString;
        }
    });
    JSON.__base__circularStringify = function (value) {
        return JSON["__base___circularStringify"](value);
    };
}
if ("undefined" === typeof JSON.__base__circularParse) {
    Object.defineProperty(JSON, "__base___circularParse", {
        writable: false,
        configurable: false,
        value: function (value, cache, parentKey) {
            let circularToken = JSON.__base__circularToken.toString();
            let temp;
            let specials = [];
            if (typeof value === "string") {
                let specialJSONs = value.match(/[A-Za-z0-9]+\(.[^\)]*\)/g) || [];
                if (specialJSONs.length > 0) {
                    specialJSONs.map((specialJSON, i) => {
                        let className = specialJSON.substring(0, specialJSON.indexOf("("));
                        if (global[className]) {
                            if (global[className] && typeof global[className].__base__fromJSON === "function") {
                                specials.push(global[className].__base__fromJSON(specialJSON));
                            }
                            else {
                                specials.push(`"${specialJSON}`);
                            }
                        }
                        else {
                            specials.push(`"${specialJSON}`);
                        }
                        value = value.replace(specialJSON, `"` + Symbol.for(`${parentKey ? parentKey : ""}${i}`).toString() + `"`);
                    });
                }
                system.log(value);
                temp = JSON.parse(value);
            }
            else
                temp = value;
            if (!cache) {
                cache = {};
                cache["root"] = temp;
            }
            else
                cache[parentKey] = temp;
            let keys = Object.keys(temp);
            Object.values(temp).map((v, i) => {
                if (v) {
                    if (typeof v === "object") {
                        let key = parentKey ? `${parentKey}.${keys[i]}` : `root.${keys[i]}`;
                        temp[keys[i]] = JSON["__base___circularParse"](v, cache, key);
                    }
                    else if (typeof v === "string" && v.indexOf(circularToken) === 0) {
                        let key = v.replace(circularToken, "").replace(/[\[\]]/g, "");
                        let delimiter = Object.__base__getDelimiter(key);
                        temp[keys[i]] = Object.__base__valueAt(cache, key, delimiter);
                    }
                }
            });
            specials.map((special, i) => {
                Object.__base__replace(temp, Symbol.for((parentKey ? parentKey : "") + i.toString()).toString(), special);
            });
            return temp;
        }
    });
    JSON.__base__circularParse = function (value) {
        let result = JSON["__base___circularParse"](value);
        return result;
    };
}
;
if ("undefined" === typeof Object.__base__replace) {
    Object.__base__replace = function (input, condition, replacer) {
        let keys = Object.keys(input);
        Object.values(input).map((value, index) => {
            if (condition && typeof condition === "object") {
                if (value && typeof value === "object") {
                    if (JSON.__base__circularStringify(value) === JSON.__base__circularStringify(condition))
                        input[keys[index]] = replacer;
                    else
                        input[keys[index]] = Object.__base__replace(value, condition, replacer);
                }
            }
            else {
                if (value && typeof value === "object")
                    input[keys[index]] = Object.__base__replace(value, condition, replacer);
                else if (value === condition)
                    input[keys[index]] = replacer;
            }
        });
        return input;
    };
}
if ("undefined" === typeof Object.__base__clone) {
    Object.__base__clone = function (source) {
        let dest;
        if (source) {
            if (typeof source === "object" && typeof source.__base__clone === "function")
                dest = source.__base__clone();
            else if (Array.isArray(source))
                dest = Array.__base__clone(source);
            else {
                dest = {};
                let keys = Object.keys(source);
                Object.values(source).map((value, index) => {
                    if (value && typeof value === "object") {
                        if (Array.isArray(value))
                            dest[keys[index]] = Array.__base__clone(value);
                        else
                            dest[keys[index]] = Object.__base__clone(value);
                    }
                    else
                        dest[keys[index]] = value;
                });
            }
        }
        else
            dest = null;
        return dest;
    };
}
if ("undefined" === typeof Object.__base__getDelimiter) {
    Object.__base__getDelimiter = function (key) {
        if (key && key.includes("."))
            return "|";
        return ".";
    };
}
if ("undefined" === typeof Object.__base__valueAt) {
    Object.__base__valueAt = function (source, key, delimiter = ".") {
        if (!delimiter)
            delimiter = ".";
        let keys = key.split(delimiter), value;
        keys.map((k, i) => {
            if (i === 0)
                value = source[k];
            else
                value = value[k];
        });
        return value;
    };
}
if ("undefined" === typeof Object.__base__setAt) {
    Object.__base__setAt = function (source, key, value, delimiter = ".") {
        if (!delimiter)
            delimiter = ".";
        let keys = typeof key === "string" ? key.split(delimiter) : [key];
        if (keys.length === 1) {
            let innerKey = keys[0];
            innerKey = Number(innerKey);
            if (isNaN(innerKey))
                innerKey = keys[0];
            source[innerKey] = value;
        }
        else {
            let innerKey = keys[0];
            keys.splice(0, 1);
            source[innerKey] = Object.__base__setAt(source[innerKey], keys.join(delimiter), value);
        }
    };
}
if ("undefined" === typeof Object.__base__flattenMap) {
    Object.__base__flattenMap = function (input) {
        if (input) {
            if (typeof input === "object" && !Array.isArray(input)) {
                if (input instanceof Map) {
                    let output = {};
                    input.forEach((value, key) => {
                        let keyString = "";
                        if (typeof key === "string") {
                            keyString = key;
                        }
                        else {
                            keyString = key.toString();
                        }
                        if (typeof value === "object" && !Array.isArray(value)) {
                            output[keyString] = Object.__base__flattenMap(value);
                        }
                        else {
                            if (Array.isArray(value)) {
                                output[keyString] = value.slice(0);
                            }
                            else {
                                output[keyString] = value;
                            }
                        }
                    });
                    return output;
                }
                else {
                    let output = {};
                    let keys = Object.keys(input);
                    Object.values(input).map((value, index) => {
                        if (typeof value === "object" && !Array.isArray(value)) {
                            output[keys[index]] = Object.__base__flattenMap(value);
                        }
                        else {
                            if (Array.isArray(value)) {
                                output[keys[index]] = value.slice(0);
                            }
                            else {
                                output[keys[index]] = value;
                            }
                        }
                    });
                    return output;
                }
            }
            else {
                throw new Error("Input must be an object or map");
            }
        }
        else {
            throw new Error("Can't convert null or undefined to object");
        }
    };
}
if ("undefined" === typeof Array.__base__clone) {
    Array.__base__clone = function (source) {
        let temp = source.slice(0);
        return temp.map(t => {
            if (typeof t === "object") {
                if (Array.isArray(t))
                    return Array.__base__clone(t);
                else
                    return Object.__base__clone(t);
            }
            else
                return t;
        });
    };
}
if ("undefined" === typeof Array.__base__toJSON) {
    Array.__base__toJSON = function (source) {
        let jsons = [];
        source.map(v => {
            if (typeof v === "object")
                jsons.push(JSON.__base__circularStringify(v));
            else if (typeof v !== "function")
                jsons.push((typeof v === "string" ? `"${v}"` : v.toString()));
        });
        let jsonString = `[${jsons.join(",")}]`;
        return jsonString;
    };
}
if ("undefined" === typeof RegExp.prototype.__base__clone) {
    RegExp.prototype.__base__clone = function () {
        return new RegExp(this);
    };
}
if ("undefined" === typeof Map.prototype.__base__clone) {
    Map.prototype.__base__clone = function () {
        let newMap = new Map();
        this.forEach((value, key) => {
            newMap.set(key, value);
        });
        return newMap;
    };
}
if ("undefined" === typeof Map.prototype.__base__toJSON) {
    Map.prototype.__base__toJSON = function () {
        let temp = this.__base__convertToObject(true);
        let jsonString = `Map(${JSON.__base__circularStringify(temp)})`;
        return jsonString;
    };
}
if ("undefined" === typeof Map.prototype.__base__convertToObject) {
    Map.prototype.__base__convertToObject = function (nested = false) {
        let obj = {};
        this.forEach((value, key) => {
            let keyString = "";
            if (typeof key === "string") {
                keyString = key;
            }
            else {
                keyString = key.toString();
            }
            if (value instanceof Map) {
                if (nested)
                    obj[keyString] = value.__base__convertToObject();
                else
                    obj[keyString] = value;
            }
            else {
                obj[keyString] = value;
            }
        });
        return obj;
    };
}
if ("undefined" === typeof Map.__base__fromObject) {
    Map.__base__fromObject = function (obj) {
        const newMap = new Map();
        if (obj) {
            let keys = Object.keys(obj);
            Object.values(obj).map((value, index) => {
                newMap.set(keys[index], value);
            });
            return newMap;
        }
        else {
            throw new Error("Can't convert null or undefined to Map");
        }
    };
}
if ("undefined" === typeof Map.__base__fromJSON) {
    Map.__base__fromJSON = function (input) {
        input = input.replace("Map(", "");
        input = input.substring(0, input.length - 1);
        let obj = JSON.__base__circularParse(input);
        let temp = Map.__base__fromObject(obj);
        return temp;
    };
}
;
if ("undefined" === typeof Date.__base__fromJSON) {
    Date.__base__fromJSON = function (input) {
        input = input.replace(/[(Date)\(\)]/g, "");
        return new Date(input);
    };
}
if ("undefined" === typeof Date.prototype.__base__toJSON) {
    Date.prototype.__base__toJSON = function () {
        return `Date(${this.toISOString()})`;
    };
}
if ("undefined" === typeof Date.prototype.__base__clone) {
    Date.prototype.__base__clone = function () {
        return new Date(this);
    };
}
;
;
if ("undefined" === typeof global["addAlias"]) {
    const Module = module.constructor || module_1.default;
    const moduleAliasNames = [];
    const moduleAliases = {};
    global["addAlias"] = function addAlias(alias, target) {
        moduleAliases[alias] = target;
        if (!moduleAliasNames.includes(alias))
            moduleAliasNames.push(alias);
    };
    global["isPathMatchesAlias"] = function isPathMatchesAlias(path, alias) {
        if (path.indexOf(alias) === 0) {
            if (path.length === alias.length)
                return true;
            if (path[alias.length] === '/')
                return true;
        }
        return false;
    };
    const oldResolveFilename = Module._resolveFilename;
    Module._resolveFilename = function (request, parentModule, isMain, options) {
        for (var i = moduleAliasNames.length; i-- > 0;) {
            var alias = moduleAliasNames[i];
            if (isPathMatchesAlias(request, alias)) {
                var aliasTarget = moduleAliases[alias];
                if (typeof moduleAliases[alias] === 'function') {
                    let fromPath = parentModule.filename;
                    aliasTarget = moduleAliases[alias](fromPath, request, alias);
                    if (!aliasTarget || typeof aliasTarget !== 'string') {
                        throw new Error('[module-alias] Expecting custom handler function to return path.');
                    }
                }
                request = path_1.join(aliasTarget, request.substr(alias.length));
                break;
            }
        }
        return oldResolveFilename.call(this, request, parentModule, isMain, options);
    };
}
;
if (typeof global["process-watch-log"] === "undefined") {
    global["process-watch-log"] = true;
    process.once("exit", (code) => {
        if (code === 1111) {
            process.stdout.write("╔══════════════════════════════════════════════════════════════╗\n");
            process.stdout.write("║                                                              ║\n");
            process.stdout.write("║                                                              ║\n");
            process.stdout.write("║           App shutdown with error has level 'RED'            ║\n");
            process.stdout.write("║                                                              ║\n");
            process.stdout.write("║                                                              ║\n");
            process.stdout.write("╚══════════════════════════════════════════════════════════════╝\n");
        }
        else {
            let errorString = `App shutdown with error has code  ${code}`;
            let space = "              ";
            let codeString = code.toString();
            let spaceLength = space.length;
            let odd = (codeString.length % 2 !== 0);
            let leftSpaceLength = odd ? spaceLength - Math.floor(codeString.length / 2) - 1 : spaceLength - Math.floor(codeString.length / 2);
            let rightSpaceLength = spaceLength - Math.floor(codeString.length / 2);
            errorString = space.substring(0, leftSpaceLength) + errorString + space.substring(0, rightSpaceLength);
            process.stdout.write("╔══════════════════════════════════════════════════════════════╗\n");
            process.stdout.write("║                                                              ║\n");
            process.stdout.write("║                                                              ║\n");
            process.stdout.write(`║${errorString}║\n`);
            process.stdout.write("║                                                              ║\n");
            process.stdout.write("║                                                              ║\n");
            process.stdout.write("╚══════════════════════════════════════════════════════════════╝\n");
        }
    }).on("uncaughtException", (err) => {
        console.error(err);
        handleError(err, ErrorLevel.RED);
    }).on("unhandledRejection", (err) => {
        console.error(err);
        handleError(err, ErrorLevel.RED);
    }).on("app-error", (err) => {
        console.error(err);
        let error = err;
        if (error.level === "red") {
            process.exit(1111);
        }
    });
}
